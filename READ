import pandas as pd

# 1. On dÃ©finit toutes les colonnes Ã  comparer (on prend tout sauf l'index si nÃ©cessaire)
cols_a_comparer = df_dupes_id.columns.tolist()

list_fusion_auto = []
list_validation = []

# 2. Groupement par l'ID commun
for tech_id, group in df_dupes_id.groupby('ID_CODE_TIERS_CRM'):
    
    # On vÃ©rifie l'unicitÃ© sur l'ensemble des colonnes
    # Si le nombre de lignes uniques est Ã©gal Ã  1, ce sont des copies conformes
    if len(group.drop_duplicates()) == 1:
        # âœ… SEMBLABLES : On garde une seule ligne pour la fusion
        list_fusion_auto.append(group.head(1))
    else:
        # âš ï¸ NON SEMBLABLES : On cherche oÃ¹ sont les Ã©carts
        diff_cols = []
        for col in cols_a_comparer:
            # nunique(dropna=False) permet de dÃ©tecter si un champ est vide d'un cÃ´tÃ© et rempli de l'autre
            if group[col].nunique(dropna=False) > 1:
                diff_cols.append(col)
        
        # On crÃ©e une copie pour ne pas modifier le DF original et on note les conflits
        group_conflit = group.copy()
        group_conflit['CHAMPS_DIFFERENTS'] = ", ".join(diff_cols)
        list_validation.append(group_conflit)

# 3. CrÃ©ation des deux DataFrames de sortie
df_pret_a_fusionner = pd.concat(list_fusion_auto).reset_index(drop=True) if list_fusion_auto else pd.DataFrame()
df_en_attente_validation = pd.concat(list_validation).reset_index(drop=True) if list_validation else pd.DataFrame()

# --- Affichage des rÃ©sultats ---
print(f"ğŸ“Š Analyse terminÃ©e :")
print(f"ğŸ”¹ Lignes identiques (prÃªtes) : {len(df_pret_a_fusionner)}")
print(f"ğŸ”¸ Lignes avec diffÃ©rences : {len(df_en_attente_validation)}")

if not df_en_attente_validation.empty:
    print("\nğŸ§ AperÃ§u des diffÃ©rences dÃ©tectÃ©es :")
    # On affiche l'ID, la colonne des diffÃ©rences, puis le reste
    cols_order = ['ID_CODE_TIERS_CRM', 'CHAMPS_DIFFERENTS'] + [c for c in cols_a_comparer if c != 'ID_CODE_TIERS_CRM']
    display(df_en_attente_validation[cols_order].head(15))